package eu._4fh.guildsync.db;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import edu.umd.cs.findbugs.annotations.NonNull;
import eu._4fh.guildsync.config.Config;

public class Transaction implements AutoCloseable {

	private static final Logger log = LoggerFactory.getLogger(Transaction.class);
	private static final ThreadLocal<Transaction> currentTransaction = new ThreadLocal<>();
	private static final Config config = Config.getInstance();

	private final @NonNull Connection connection;
	private int usageCounter;

	private static Connection connect() throws SQLException {
		Properties info = new Properties();
		info.put("user", config.dbUser());
		info.put("password", config.dbPassword());
		info.put("connectTimeout", 30000);
		return DriverManager.getConnection(config.dbUrl(), info);
	}

	private Transaction(final @NonNull Connection connection) {
		try {
			connection.setAutoCommit(false);
		} catch (SQLException e) {
			try {
				connection.close();
			} catch (Throwable t) {
				// Ignore
			}
			throw new RuntimeException(e);
		}
		currentTransaction.set(this);
		this.connection = connection;
		usageCounter = 1;
		log.debug("BEGIN");
	}

	@Override
	public void close() {
		usageCounter--;
		if (usageCounter > 0) {
			return;
		}
		try {
			currentTransaction.remove();
			connection.rollback();
			connection.close();
			log.debug("END");
		} catch (SQLException e) {
			try {
				connection.close();
			} catch (Throwable t) {
				// Ignore
			}
			throw new RuntimeException(e);
		}
	}

	public void commit() throws SQLException {
		if (usageCounter != 1) {
			log.debug("Suppress commit, only most outer level can commit");
			return;
		}
		connection.commit();
		log.debug("COMMIT");
	}

	public static Transaction getTransaction() {
		Transaction transaction = currentTransaction.get();
		if (transaction != null) {
			transaction.incUsage();
			return transaction;
		}
		try {
			transaction = new Transaction(connect());
			return transaction;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}

	private void incUsage() {
		usageCounter++;
	}

	protected PreparedStatement prepareStatement(String sql, int autoGeneratedKeys) throws SQLException {
		log.debug("Prepare " + sql);
		return connection.prepareStatement(sql, autoGeneratedKeys);
	}

	protected PreparedStatement prepareStatement(String sql) throws SQLException {
		return prepareStatement(sql, Statement.NO_GENERATED_KEYS);
	}
}
